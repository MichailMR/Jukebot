import asyncio

import pytube
import pafy

import discord
from discord.ext import commands

class jukebox:
    def __init__():
        pass

class playlist:
    def __init__(self, id):
        ###data about the playlist
        self.id = id #channel.id
        
        ###class vars
        self.playlist = []
        self.voice_channels = {"channels":[],"id's":[]}
        
    def front(self, input, is_title=True):
        ###Get youtube url
        if is_title:
                #need to find yt url from title
            pass
        else:
            yt_url = input
            
        self.playlist += [{"yt_url":yt_url}]
        
        ###convert youtube url to stream url
            #needs to go elsewhere
        """
        video = pafy.new(url)
        best = video.getbestaudio()
        playurl = best.url
        """

    def create_jukebox(self):
        self.jukebox = jukebox()

class client:
    def __init__(self):
        ###class vars
        self.playlists = {"lists":[],"channels":[]}

        ###bot stuff
        self.token = 'MTAzODUwNzIxNDMwODEzMDg0Nw.Gq6yK2.NmGmahw4biYN9stOR8KKq1Tyl0QrI3mS359gqQ'
        self.bot = commands.Bot(command_prefix = '?', Intents=discord.Intents.all())
        
        @self.bot.event
        async def on_ready():
            print('Marble is ready!')

        ###create commands
        ###test ping
        @self.bot.command(help = 'Returns message saying "pong"')
        async def ping(ctx):
            await ctx.send('pong')
        
        ###insert a "coin" to play song
        @self.bot.command(help = 'Select a song to play')
        async def insert(ctx, *args, is_link=False):
            song_name = args[0]
            
            playlists_index = self.check_playlist(ctx)
                #is_title = True is useless at the point
            playlists["lists"][playlists_index].front(song_name, is_title=not is_link)
            
            await ctx.send(f'Playling {song_name}')
        
        ###get info on playlist
        @self.bot.command(help = 'Retrieves playlist data from text channel')
        async def playlist(ctx):
                #currently only id, but in future also next songs and N songs
            await ctx.send(f'playlist id is {ctx.channel.id}')

    def check_playlist(self, ctx):
        ###Create playlist and retrieve id index
        if not ctx.channel in self.playlists["channels"]:
            self.playlists["channels"] += [ctx.channel.id]
            self.playlists["lists"] += [playlist(ctx.channel.id)]
        
            #need to store self.playlists in json file for in-between-sesions storage
        
        return self.playlists["channels"].index(ctx.channel.id)
    
    def run(self):
        ###runs bot in discord
        self.bot.run(self.token)
        
    async def close(self):
        ###closes bot from discord
        await self.bot.logout()

###creates and runs a client
client = client()
client.run()

"""
    #need signal and sys libraries
    #tried and failed to handle exit loop
def handler(sig, frame):
    sys.exit(0)

signal.signal(signal.SIGINT, handler)
"""


"""
Playlist is connected to one text channel
Playlist can create serveral jukeboxes wich al sing the some, current song
Multiple jukeboxes can be connected to a voice channel
"""